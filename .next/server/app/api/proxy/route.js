"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/proxy/route";
exports.ids = ["app/api/proxy/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fproxy%2Froute&page=%2Fapi%2Fproxy%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fproxy%2Froute.ts&appDir=D%3A%5Csolana-staking-dashboard%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=D%3A%5Csolana-staking-dashboard&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fproxy%2Froute&page=%2Fapi%2Fproxy%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fproxy%2Froute.ts&appDir=D%3A%5Csolana-staking-dashboard%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=D%3A%5Csolana-staking-dashboard&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var D_solana_staking_dashboard_src_app_api_proxy_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/proxy/route.ts */ \"(rsc)/./src/app/api/proxy/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/proxy/route\",\n        pathname: \"/api/proxy\",\n        filename: \"route\",\n        bundlePath: \"app/api/proxy/route\"\n    },\n    resolvedPagePath: \"D:\\\\solana-staking-dashboard\\\\src\\\\app\\\\api\\\\proxy\\\\route.ts\",\n    nextConfigOutput,\n    userland: D_solana_staking_dashboard_src_app_api_proxy_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/proxy/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZwcm94eSUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGcHJveHklMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZwcm94eSUyRnJvdXRlLnRzJmFwcERpcj1EJTNBJTVDc29sYW5hLXN0YWtpbmctZGFzaGJvYXJkJTVDc3JjJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1EJTNBJTVDc29sYW5hLXN0YWtpbmctZGFzaGJvYXJkJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNZO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sYW5hLXN0YWtpbmctZGFzaGJvYXJkLz9mYjhlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkQ6XFxcXHNvbGFuYS1zdGFraW5nLWRhc2hib2FyZFxcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFxwcm94eVxcXFxyb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcHJveHkvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9wcm94eVwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvcHJveHkvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJEOlxcXFxzb2xhbmEtc3Rha2luZy1kYXNoYm9hcmRcXFxcc3JjXFxcXGFwcFxcXFxhcGlcXFxccHJveHlcXFxccm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL3Byb3h5L3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fproxy%2Froute&page=%2Fapi%2Fproxy%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fproxy%2Froute.ts&appDir=D%3A%5Csolana-staking-dashboard%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=D%3A%5Csolana-staking-dashboard&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/proxy/route.ts":
/*!************************************!*\
  !*** ./src/app/api/proxy/route.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_api_solana__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api/solana */ \"(rsc)/./src/lib/api/solana.ts\");\n\n\nconst API_KEY = \"b3f80ab3-e78f-4a48-be9e-0a86ddf031ae\";\n// Simple in-memory cache for validator data\nconst validatorCache = new Map();\nconst VALIDATOR_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n// Rate limiting configuration\nconst RATE_LIMIT_REQUESTS = 10;\nconst RATE_LIMIT_WINDOW = 5 * 60 * 1000; // 5 minutes\nconst MAX_RETRIES = 2;\nconst INITIAL_RETRY_DELAY = 2000; // Increased from 1 second\nconst requestCounts = new Map();\nfunction checkRateLimit(endpoint) {\n    const now = Date.now();\n    const key = `${endpoint}:${Math.floor(now / RATE_LIMIT_WINDOW)}`;\n    const current = requestCounts.get(key) || {\n        count: 0,\n        resetTime: now + RATE_LIMIT_WINDOW\n    };\n    if (now > current.resetTime) {\n        requestCounts.set(key, {\n            count: 1,\n            resetTime: now + RATE_LIMIT_WINDOW\n        });\n        return true;\n    }\n    if (current.count >= RATE_LIMIT_REQUESTS) {\n        return false;\n    }\n    current.count++;\n    requestCounts.set(key, current);\n    return true;\n}\nasync function fetchWithRetry(url, options, retries = 0) {\n    try {\n        const response = await fetch(url, options);\n        if (response.status === 429 && retries < MAX_RETRIES) {\n            const delay = INITIAL_RETRY_DELAY * Math.pow(2, retries);\n            await new Promise((resolve)=>setTimeout(resolve, delay));\n            return fetchWithRetry(url, options, retries + 1);\n        }\n        return response;\n    } catch (error) {\n        if (retries < MAX_RETRIES) {\n            const delay = INITIAL_RETRY_DELAY * Math.pow(2, retries);\n            await new Promise((resolve)=>setTimeout(resolve, delay));\n            return fetchWithRetry(url, options, retries + 1);\n        }\n        throw error;\n    }\n}\nasync function GET(request) {\n    try {\n        if (!API_KEY) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"API key is required\"\n            }, {\n                status: 401\n            });\n        }\n        const { searchParams } = new URL(request.url);\n        const endpoint = searchParams.get(\"endpoint\");\n        const limit = searchParams.get(\"limit\");\n        const offset = searchParams.get(\"offset\");\n        if (!endpoint) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Endpoint parameter is required\"\n            }, {\n                status: 400\n            });\n        }\n        // Special handling for validator endpoints\n        if (endpoint.includes(\"/validators/\")) {\n            const cacheKey = `${endpoint}?limit=${limit}&offset=${offset}`;\n            const cached = validatorCache.get(cacheKey);\n            if (cached && Date.now() - cached.timestamp < VALIDATOR_CACHE_TTL) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(cached.data);\n            }\n            // Check rate limit before making the request\n            if (!checkRateLimit(endpoint)) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Rate limit exceeded. Please try again later.\"\n                }, {\n                    status: 429\n                });\n            }\n            const url = new URL(`${_lib_api_solana__WEBPACK_IMPORTED_MODULE_1__.SOLANA_BEACH_API}${endpoint}`);\n            if (limit) url.searchParams.append(\"limit\", limit);\n            if (offset) url.searchParams.append(\"offset\", offset);\n            const response = await fetchWithRetry(url.toString(), {\n                headers: {\n                    \"Accept\": \"application/json\",\n                    \"Content-Type\": \"application/json\",\n                    \"Authorization\": `Bearer ${API_KEY}`\n                }\n            });\n            if (!response.ok) {\n                if (response.status === 429) {\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: \"Rate limit exceeded. Please try again later.\"\n                    }, {\n                        status: 429\n                    });\n                }\n                throw new Error(`API error: ${response.status} ${response.statusText}`);\n            }\n            const data = await response.json();\n            // Cache the validator data\n            validatorCache.set(cacheKey, {\n                data,\n                timestamp: Date.now()\n            });\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(data);\n        }\n        // For non-validator endpoints, proceed with normal proxy logic\n        const url = new URL(`${_lib_api_solana__WEBPACK_IMPORTED_MODULE_1__.SOLANA_BEACH_API}${endpoint}`);\n        if (limit) url.searchParams.append(\"limit\", limit);\n        if (offset) url.searchParams.append(\"offset\", offset);\n        const response = await fetchWithRetry(url.toString(), {\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": `Bearer ${API_KEY}`\n            }\n        });\n        if (!response.ok) {\n            throw new Error(`API error: ${response.status} ${response.statusText}`);\n        }\n        const data = await response.json();\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(data);\n    } catch (error) {\n        console.error(\"Proxy error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: error instanceof Error ? error.message : \"Failed to fetch data\"\n        }, {\n            status: 500\n        });\n    }\n}\n// Handle OPTIONS request for CORS preflight\nasync function OPTIONS() {\n    return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n        status: 204,\n        headers: {\n            \"Access-Control-Allow-Origin\": \"*\",\n            \"Access-Control-Allow-Methods\": \"GET, OPTIONS\",\n            \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\"\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ2hDLGdDQUFnQztRQUNsQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2xhbmEtc3Rha2luZy1kYXNoYm9hcmQvLi9zcmMvYXBwL2FwaS9wcm94eS9yb3V0ZS50cz9kODI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHsgU09MQU5BX0JFQUNIX0FQSSB9IGZyb20gJ0AvbGliL2FwaS9zb2xhbmEnO1xyXG5cclxuY29uc3QgQVBJX0tFWSA9IHByb2Nlc3MuZW52LlNPTEFOQV9CRUFDSF9BUElfS0VZO1xyXG5cclxuLy8gU2ltcGxlIGluLW1lbW9yeSBjYWNoZSBmb3IgdmFsaWRhdG9yIGRhdGFcclxuY29uc3QgdmFsaWRhdG9yQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgeyBkYXRhOiBhbnk7IHRpbWVzdGFtcDogbnVtYmVyIH0+KCk7XHJcbmNvbnN0IFZBTElEQVRPUl9DQUNIRV9UVEwgPSA1ICogNjAgKiAxMDAwOyAvLyA1IG1pbnV0ZXNcclxuXHJcbi8vIFJhdGUgbGltaXRpbmcgY29uZmlndXJhdGlvblxyXG5jb25zdCBSQVRFX0xJTUlUX1JFUVVFU1RTID0gMTA7XHJcbmNvbnN0IFJBVEVfTElNSVRfV0lORE9XID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzXHJcbmNvbnN0IE1BWF9SRVRSSUVTID0gMjtcclxuY29uc3QgSU5JVElBTF9SRVRSWV9ERUxBWSA9IDIwMDA7IC8vIEluY3JlYXNlZCBmcm9tIDEgc2Vjb25kXHJcblxyXG5jb25zdCByZXF1ZXN0Q291bnRzID0gbmV3IE1hcDxzdHJpbmcsIHsgY291bnQ6IG51bWJlcjsgcmVzZXRUaW1lOiBudW1iZXIgfT4oKTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrUmF0ZUxpbWl0KGVuZHBvaW50OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fToke01hdGguZmxvb3Iobm93IC8gUkFURV9MSU1JVF9XSU5ET1cpfWA7XHJcbiAgXHJcbiAgY29uc3QgY3VycmVudCA9IHJlcXVlc3RDb3VudHMuZ2V0KGtleSkgfHwgeyBjb3VudDogMCwgcmVzZXRUaW1lOiBub3cgKyBSQVRFX0xJTUlUX1dJTkRPVyB9O1xyXG4gIFxyXG4gIGlmIChub3cgPiBjdXJyZW50LnJlc2V0VGltZSkge1xyXG4gICAgcmVxdWVzdENvdW50cy5zZXQoa2V5LCB7IGNvdW50OiAxLCByZXNldFRpbWU6IG5vdyArIFJBVEVfTElNSVRfV0lORE9XIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChjdXJyZW50LmNvdW50ID49IFJBVEVfTElNSVRfUkVRVUVTVFMpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgY3VycmVudC5jb3VudCsrO1xyXG4gIHJlcXVlc3RDb3VudHMuc2V0KGtleSwgY3VycmVudCk7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aFJldHJ5KHVybDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCwgcmV0cmllcyA9IDApOiBQcm9taXNlPFJlc3BvbnNlPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcclxuICAgIFxyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5ICYmIHJldHJpZXMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgICBjb25zdCBkZWxheSA9IElOSVRJQUxfUkVUUllfREVMQVkgKiBNYXRoLnBvdygyLCByZXRyaWVzKTtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XHJcbiAgICAgIHJldHVybiBmZXRjaFdpdGhSZXRyeSh1cmwsIG9wdGlvbnMsIHJldHJpZXMgKyAxKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBpZiAocmV0cmllcyA8IE1BWF9SRVRSSUVTKSB7XHJcbiAgICAgIGNvbnN0IGRlbGF5ID0gSU5JVElBTF9SRVRSWV9ERUxBWSAqIE1hdGgucG93KDIsIHJldHJpZXMpO1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcclxuICAgICAgcmV0dXJuIGZldGNoV2l0aFJldHJ5KHVybCwgb3B0aW9ucywgcmV0cmllcyArIDEpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3Q6IFJlcXVlc3QpIHtcclxuICB0cnkge1xyXG4gICAgaWYgKCFBUElfS0VZKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IGVycm9yOiAnQVBJIGtleSBpcyByZXF1aXJlZCcgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAxIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IHNlYXJjaFBhcmFtcy5nZXQoJ2VuZHBvaW50Jyk7XHJcbiAgICBjb25zdCBsaW1pdCA9IHNlYXJjaFBhcmFtcy5nZXQoJ2xpbWl0Jyk7XHJcbiAgICBjb25zdCBvZmZzZXQgPSBzZWFyY2hQYXJhbXMuZ2V0KCdvZmZzZXQnKTtcclxuICAgIFxyXG4gICAgaWYgKCFlbmRwb2ludCkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ0VuZHBvaW50IHBhcmFtZXRlciBpcyByZXF1aXJlZCcgfSwgeyBzdGF0dXM6IDQwMCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB2YWxpZGF0b3IgZW5kcG9pbnRzXHJcbiAgICBpZiAoZW5kcG9pbnQuaW5jbHVkZXMoJy92YWxpZGF0b3JzLycpKSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7ZW5kcG9pbnR9P2xpbWl0PSR7bGltaXR9Jm9mZnNldD0ke29mZnNldH1gO1xyXG4gICAgICBjb25zdCBjYWNoZWQgPSB2YWxpZGF0b3JDYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG4gICAgICBcclxuICAgICAgaWYgKGNhY2hlZCAmJiBEYXRlLm5vdygpIC0gY2FjaGVkLnRpbWVzdGFtcCA8IFZBTElEQVRPUl9DQUNIRV9UVEwpIHtcclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oY2FjaGVkLmRhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayByYXRlIGxpbWl0IGJlZm9yZSBtYWtpbmcgdGhlIHJlcXVlc3RcclxuICAgICAgaWYgKCFjaGVja1JhdGVMaW1pdChlbmRwb2ludCkpIHtcclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgICB7IGVycm9yOiAnUmF0ZSBsaW1pdCBleGNlZWRlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nIH0sXHJcbiAgICAgICAgICB7IHN0YXR1czogNDI5IH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke1NPTEFOQV9CRUFDSF9BUEl9JHtlbmRwb2ludH1gKTtcclxuICAgICAgaWYgKGxpbWl0KSB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnbGltaXQnLCBsaW1pdCk7XHJcbiAgICAgIGlmIChvZmZzZXQpIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdvZmZzZXQnLCBvZmZzZXQpO1xyXG5cclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSh1cmwudG9TdHJpbmcoKSwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7QVBJX0tFWX1gXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICAgICAgeyBlcnJvcjogJ1JhdGUgbGltaXQgZXhjZWVkZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyB9LFxyXG4gICAgICAgICAgICB7IHN0YXR1czogNDI5IH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2FjaGUgdGhlIHZhbGlkYXRvciBkYXRhXHJcbiAgICAgIHZhbGlkYXRvckNhY2hlLnNldChjYWNoZUtleSwge1xyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZvciBub24tdmFsaWRhdG9yIGVuZHBvaW50cywgcHJvY2VlZCB3aXRoIG5vcm1hbCBwcm94eSBsb2dpY1xyXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtTT0xBTkFfQkVBQ0hfQVBJfSR7ZW5kcG9pbnR9YCk7XHJcbiAgICBpZiAobGltaXQpIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdsaW1pdCcsIGxpbWl0KTtcclxuICAgIGlmIChvZmZzZXQpIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdvZmZzZXQnLCBvZmZzZXQpO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkodXJsLnRvU3RyaW5nKCksIHtcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtBUElfS0VZfWBcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKGRhdGEpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdQcm94eSBlcnJvcjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgIHsgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBmZXRjaCBkYXRhJyB9LFxyXG4gICAgICB7IHN0YXR1czogNTAwIH1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIYW5kbGUgT1BUSU9OUyByZXF1ZXN0IGZvciBDT1JTIHByZWZsaWdodFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gT1BUSU9OUygpIHtcclxuICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XHJcbiAgICBzdGF0dXM6IDIwNCxcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6ICcqJyxcclxuICAgICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHMnOiAnR0VULCBPUFRJT05TJyxcclxuICAgICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMnOiAnQ29udGVudC1UeXBlLCBBdXRob3JpemF0aW9uJ1xyXG4gICAgfVxyXG4gIH0pO1xyXG59ICJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJTT0xBTkFfQkVBQ0hfQVBJIiwiQVBJX0tFWSIsInByb2Nlc3MiLCJlbnYiLCJTT0xBTkFfQkVBQ0hfQVBJX0tFWSIsInZhbGlkYXRvckNhY2hlIiwiTWFwIiwiVkFMSURBVE9SX0NBQ0hFX1RUTCIsIlJBVEVfTElNSVRfUkVRVUVTVFMiLCJSQVRFX0xJTUlUX1dJTkRPVyIsIk1BWF9SRVRSSUVTIiwiSU5JVElBTF9SRVRSWV9ERUxBWSIsInJlcXVlc3RDb3VudHMiLCJjaGVja1JhdGVMaW1pdCIsImVuZHBvaW50Iiwibm93IiwiRGF0ZSIsImtleSIsIk1hdGgiLCJmbG9vciIsImN1cnJlbnQiLCJnZXQiLCJjb3VudCIsInJlc2V0VGltZSIsInNldCIsImZldGNoV2l0aFJldHJ5IiwidXJsIiwib3B0aW9ucyIsInJldHJpZXMiLCJyZXNwb25zZSIsImZldGNoIiwic3RhdHVzIiwiZGVsYXkiLCJwb3ciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJlcnJvciIsIkdFVCIsInJlcXVlc3QiLCJqc29uIiwic2VhcmNoUGFyYW1zIiwiVVJMIiwibGltaXQiLCJvZmZzZXQiLCJpbmNsdWRlcyIsImNhY2hlS2V5IiwiY2FjaGVkIiwidGltZXN0YW1wIiwiZGF0YSIsImFwcGVuZCIsInRvU3RyaW5nIiwiaGVhZGVycyIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiY29uc29sZSIsIm1lc3NhZ2UiLCJPUFRJT05TIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/proxy/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/api/solana.ts":
/*!*******************************!*\
  !*** ./src/lib/api/solana.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_BEACH_API: () => (/* binding */ SOLANA_BEACH_API),\n/* harmony export */   getGeneralInfo: () => (/* binding */ getGeneralInfo),\n/* harmony export */   getMarketData: () => (/* binding */ getMarketData),\n/* harmony export */   getNetworkStatus: () => (/* binding */ getNetworkStatus),\n/* harmony export */   getRecentBlocks: () => (/* binding */ getRecentBlocks),\n/* harmony export */   getRecentTransactions: () => (/* binding */ getRecentTransactions),\n/* harmony export */   getSupplyBreakdown: () => (/* binding */ getSupplyBreakdown),\n/* harmony export */   getTPS: () => (/* binding */ getTPS),\n/* harmony export */   getTopValidators: () => (/* binding */ getTopValidators)\n/* harmony export */ });\n/* harmony import */ var _redis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../redis */ \"(rsc)/./src/lib/redis.ts\");\n\n// Base URL for Solana Beach API\nconst SOLANA_BEACH_API = \"https://public-api.solanabeach.io\" || 0;\nconst API_KEY = \"b3f80ab3-e78f-4a48-be9e-0a86ddf031ae\";\n// Rate limiting configuration\nconst RATE_LIMIT_REQUESTS = parseInt(process.env.RATE_LIMIT_REQUESTS || \"50\", 10);\nconst RATE_LIMIT_WINDOW = parseInt(process.env.RATE_LIMIT_WINDOW || \"60\", 10); // 60 seconds\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 1000; // 1 second\n// Common headers for API requests\nconst headers = {\n    \"Accept\": \"application/json\",\n    \"Content-Type\": \"application/json\",\n    ...API_KEY ? {\n        \"Authorization\": `Bearer ${API_KEY}`\n    } : {}\n};\n// Error handling\nclass SolanaApiError extends Error {\n    constructor(code, message, details){\n        super(message);\n        this.code = code;\n        this.details = details;\n        this.name = \"SolanaApiError\";\n    }\n}\n// Rate limiting implementation\nconst requestCounts = new Map();\nfunction checkRateLimit(endpoint) {\n    const now = Date.now();\n    const key = `${endpoint}:${Math.floor(now / 1000 / RATE_LIMIT_WINDOW)}`;\n    const current = requestCounts.get(key) || {\n        count: 0,\n        resetTime: now + RATE_LIMIT_WINDOW * 1000\n    };\n    if (now > current.resetTime) {\n        requestCounts.set(key, {\n            count: 1,\n            resetTime: now + RATE_LIMIT_WINDOW * 1000\n        });\n        return true;\n    }\n    if (current.count >= RATE_LIMIT_REQUESTS) {\n        return false;\n    }\n    current.count++;\n    requestCounts.set(key, current);\n    return true;\n}\n// Generic fetch function with caching, rate limiting, and error handling\nasync function fetchWithCache(endpoint, cacheKey, ttl = _redis__WEBPACK_IMPORTED_MODULE_0__.CACHE_TTL.MEDIUM) {\n    let retries = 0;\n    while(retries < MAX_RETRIES){\n        try {\n            // Check rate limit\n            if (!checkRateLimit(endpoint)) {\n                throw new SolanaApiError(\"RATE_LIMIT_EXCEEDED\", \"Rate limit exceeded. Please try again later.\");\n            }\n            // Check cache first\n            const cachedData = await (0,_redis__WEBPACK_IMPORTED_MODULE_0__.getCachedData)(cacheKey);\n            if (cachedData) {\n                return cachedData;\n            }\n            // Use proxy for all external API calls\n            const response = await fetch(`/api/proxy?endpoint=${endpoint}`, {\n                headers: {\n                    \"Accept\": \"application/json\",\n                    \"Content-Type\": \"application/json\"\n                },\n                cache: \"no-store\"\n            });\n            if (response.status === 429) {\n                // Rate limit hit, wait and retry\n                await new Promise((resolve)=>setTimeout(resolve, RETRY_DELAY * Math.pow(2, retries)));\n                retries++;\n                continue;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new SolanaApiError(\"API_ERROR\", `API error: ${response.status} ${response.statusText}`, errorData);\n            }\n            const data = await response.json();\n            const apiResponse = {\n                data,\n                timestamp: Date.now(),\n                success: true\n            };\n            // Cache the response\n            await (0,_redis__WEBPACK_IMPORTED_MODULE_0__.setCachedData)(cacheKey, apiResponse, ttl);\n            return apiResponse;\n        } catch (error) {\n            if (retries < MAX_RETRIES - 1) {\n                await new Promise((resolve)=>setTimeout(resolve, RETRY_DELAY * Math.pow(2, retries)));\n                retries++;\n                continue;\n            }\n            throw error;\n        }\n    }\n    throw new SolanaApiError(\"MAX_RETRIES_EXCEEDED\", \"Maximum number of retries exceeded\");\n}\n// Network Status\nasync function getNetworkStatus() {\n    try {\n        // Direct fetch without caching for network status to ensure fresh data\n        const response = await fetch(`${SOLANA_BEACH_API}/v1/network-status`, {\n            headers,\n            cache: \"no-store\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new SolanaApiError(\"API_ERROR\", `API error: ${response.status} ${response.statusText}`, errorData);\n        }\n        const data = await response.json();\n        const apiResponse = {\n            data,\n            timestamp: Date.now(),\n            success: true\n        };\n        return apiResponse;\n    } catch (error) {\n        if (error instanceof SolanaApiError) {\n            throw error;\n        }\n        throw new SolanaApiError(\"FETCH_ERROR\", error instanceof Error ? error.message : \"Unknown error occurred\", error);\n    }\n}\n// Supply Breakdown\nasync function getSupplyBreakdown() {\n    try {\n        const response = await fetchWithCache(\"/v2/supply-breakdown\", \"solana:supply-breakdown\", _redis__WEBPACK_IMPORTED_MODULE_0__.CACHE_TTL.MEDIUM);\n        // Log the raw response for debugging\n        console.log(\"Raw supply breakdown response:\", response);\n        // Transform the data to match the expected structure\n        const transformedData = {\n            supply: {\n                circulating: Number(response.data.supply.circulating) || 0,\n                nonCirculating: Number(response.data.supply.nonCirculating) || 0,\n                total: Number(response.data.supply.total) || 0\n            },\n            stake: {\n                effective: Number(response.data.stake.effective) || 0,\n                activating: Number(response.data.stake.activating) || 0,\n                deactivating: Number(response.data.stake.deactivating) || 0\n            }\n        };\n        // Validate the transformed data\n        if (!isValidSupplyData(transformedData)) {\n            throw new SolanaApiError(\"INVALID_DATA\", \"Invalid supply data structure received from API\", transformedData);\n        }\n        return {\n            data: transformedData,\n            timestamp: Date.now(),\n            success: true\n        };\n    } catch (error) {\n        if (error instanceof SolanaApiError) {\n            throw error;\n        }\n        throw new SolanaApiError(\"FETCH_ERROR\", error instanceof Error ? error.message : \"Unknown error occurred\", error);\n    }\n}\n// Helper function to validate supply data\nfunction isValidSupplyData(data) {\n    return typeof data === \"object\" && data !== null && typeof data.supply === \"object\" && typeof data.supply.circulating === \"number\" && typeof data.supply.nonCirculating === \"number\" && typeof data.supply.total === \"number\" && typeof data.stake === \"object\" && typeof data.stake.effective === \"number\" && typeof data.stake.activating === \"number\" && typeof data.stake.deactivating === \"number\";\n}\n// TPS\nasync function getTPS() {\n    try {\n        // Direct fetch without caching for TPS to ensure real-time data\n        const response = await fetch(\"/api/tps\", {\n            cache: \"no-store\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new SolanaApiError(\"API_ERROR\", `API error: ${response.status} ${response.statusText}`, errorData);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        if (error instanceof SolanaApiError) {\n            throw error;\n        }\n        throw new SolanaApiError(\"FETCH_ERROR\", error instanceof Error ? error.message : \"Unknown error occurred\", error);\n    }\n}\n// Market Data\nasync function getMarketData() {\n    try {\n        const response = await fetch(\"/api/market-data\", {\n            cache: \"no-store\"\n        });\n        if (!response.ok) {\n            throw new SolanaApiError(\"API_ERROR\", `API error: ${response.status} ${response.statusText}`);\n        }\n        const data = await response.json();\n        if (!data || !data.data) {\n            throw new SolanaApiError(\"INVALID_DATA\", \"Invalid market data response\");\n        }\n        return {\n            data: data.data,\n            timestamp: data.timestamp || Date.now(),\n            success: true\n        };\n    } catch (error) {\n        if (error instanceof SolanaApiError) {\n            throw error;\n        }\n        throw new SolanaApiError(\"FETCH_ERROR\", error instanceof Error ? error.message : \"Unknown error occurred\", error);\n    }\n}\n// Recent Blocks\nasync function getRecentBlocks(limit = 50, offset = 0) {\n    try {\n        if (!API_KEY) {\n            throw new SolanaApiError(\"API_KEY_MISSING\", \"Solana Beach API key is required\");\n        }\n        const response = await fetch(`${SOLANA_BEACH_API}/v2/recent-blocks?limit=${limit}&offset=${offset}`, {\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Authorization\": `Bearer ${API_KEY}`\n            },\n            cache: \"no-store\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new SolanaApiError(\"API_ERROR\", `API error: ${response.status} ${response.statusText}`, errorData);\n        }\n        const data = await response.json();\n        // Validate the response data\n        if (!data || !Array.isArray(data.blocks)) {\n            throw new SolanaApiError(\"INVALID_DATA\", \"Invalid response format from API\", data);\n        }\n        return {\n            data: {\n                blocks: data.blocks,\n                pagination: {\n                    total: data.pagination?.total || data.blocks.length,\n                    offset: data.pagination?.offset || offset,\n                    limit: data.pagination?.limit || limit\n                }\n            },\n            timestamp: Date.now(),\n            success: true\n        };\n    } catch (error) {\n        if (error instanceof SolanaApiError) {\n            throw error;\n        }\n        throw new SolanaApiError(\"FETCH_ERROR\", error instanceof Error ? error.message : \"Unknown error occurred\", error);\n    }\n}\n// Recent Transactions\nasync function getRecentTransactions(limit = 50, offset = 0) {\n    try {\n        const API_KEY = \"b3f80ab3-e78f-4a48-be9e-0a86ddf031ae\";\n        if (!API_KEY) {\n            throw new SolanaApiError(\"API_KEY_MISSING\", \"Solana Beach API key is required\");\n        }\n        const response = await fetch(`${SOLANA_BEACH_API}/v1/latest-transactions?limit=${limit}&offset=${offset}`, {\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Authorization\": `Bearer ${API_KEY}`\n            },\n            cache: \"no-store\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new SolanaApiError(\"API_ERROR\", `API error: ${response.status} ${response.statusText}`, errorData);\n        }\n        const data = await response.json();\n        // Validate the response data\n        if (!data || !Array.isArray(data)) {\n            throw new SolanaApiError(\"INVALID_DATA\", \"Invalid response format from API\", data);\n        }\n        return {\n            data: {\n                transactions: data,\n                pagination: {\n                    total: data.length,\n                    offset: offset,\n                    limit: limit\n                }\n            },\n            timestamp: Date.now(),\n            success: true\n        };\n    } catch (error) {\n        if (error instanceof SolanaApiError) {\n            throw error;\n        }\n        throw new SolanaApiError(\"FETCH_ERROR\", error instanceof Error ? error.message : \"Unknown error occurred\", error);\n    }\n}\n// Get Top Validators\nasync function getTopValidators(limit = 100, offset = 0) {\n    try {\n        if (!API_KEY) {\n            throw new SolanaApiError(\"API_KEY_MISSING\", \"Solana Beach API key is required\");\n        }\n        const response = await fetch(`/api/proxy?endpoint=/v1/validators/top&limit=${limit}&offset=${offset}`, {\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/json\"\n            },\n            cache: \"no-store\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new SolanaApiError(\"API_ERROR\", `API error: ${response.status} ${response.statusText}`, errorData);\n        }\n        const data = await response.json();\n        // Validate the response data\n        if (!data || !Array.isArray(data)) {\n            throw new SolanaApiError(\"INVALID_DATA\", \"Invalid response format from API\", data);\n        }\n        return {\n            data,\n            timestamp: Date.now(),\n            success: true\n        };\n    } catch (error) {\n        if (error instanceof SolanaApiError) {\n            throw error;\n        }\n        throw new SolanaApiError(\"FETCH_ERROR\", \"Failed to fetch validators\", error);\n    }\n}\n// Get General Info\nasync function getGeneralInfo() {\n    try {\n        if (!API_KEY) {\n            throw new SolanaApiError(\"API_KEY_MISSING\", \"Solana Beach API key is required\");\n        }\n        const response = await fetch(\"/api/proxy?endpoint=/v1/general-info\", {\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/json\"\n            },\n            cache: \"no-store\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new SolanaApiError(\"API_ERROR\", `API error: ${response.status} ${response.statusText}`, errorData);\n        }\n        const data = await response.json();\n        // Validate the response data\n        if (!data) {\n            throw new SolanaApiError(\"INVALID_DATA\", \"Invalid response format from API\", data);\n        }\n        return {\n            data,\n            timestamp: Date.now(),\n            success: true\n        };\n    } catch (error) {\n        if (error instanceof SolanaApiError) {\n            throw error;\n        }\n        throw new SolanaApiError(\"FETCH_ERROR\", error instanceof Error ? error.message : \"Unknown error occurred\", error);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2FwaS9zb2xhbmEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUNtRTtBQUVuRSxnQ0FBZ0M7QUFDekIsTUFBTUcsbUJBQW1CQyxtQ0FBNEMsSUFBSSxFQUFvQztBQUNwSCxNQUFNRyxVQUFVSCxzQ0FBZ0M7QUFFaEQsOEJBQThCO0FBQzlCLE1BQU1LLHNCQUFzQkMsU0FBU04sUUFBUUMsR0FBRyxDQUFDSSxtQkFBbUIsSUFBSSxNQUFNO0FBQzlFLE1BQU1FLG9CQUFvQkQsU0FBU04sUUFBUUMsR0FBRyxDQUFDTSxpQkFBaUIsSUFBSSxNQUFNLEtBQUssYUFBYTtBQUM1RixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGNBQWMsTUFBTSxXQUFXO0FBRXJDLGtDQUFrQztBQUNsQyxNQUFNQyxVQUFVO0lBQ2QsVUFBVTtJQUNWLGdCQUFnQjtJQUNoQixHQUFJUCxVQUFVO1FBQUUsaUJBQWlCLENBQUMsT0FBTyxFQUFFQSxRQUFRLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztBQUM3RDtBQUVBLGlCQUFpQjtBQUNqQixNQUFNUSx1QkFBdUJDO0lBQzNCQyxZQUNFLElBQW1CLEVBQ25CRSxPQUFlLEVBQ2YsT0FBd0IsQ0FDeEI7UUFDQSxLQUFLLENBQUNBO2FBSkNELE9BQUFBO2FBRUFFLFVBQUFBO1FBR1AsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsK0JBQStCO0FBQy9CLE1BQU1DLGdCQUFnQixJQUFJQztBQUUxQixTQUFTQyxlQUFlQyxRQUFnQjtJQUN0QyxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO0lBQ3BCLE1BQU1FLE1BQU0sQ0FBQyxFQUFFSCxTQUFTLENBQUMsRUFBRUksS0FBS0MsS0FBSyxDQUFDSixNQUFNLE9BQU9mLG1CQUFtQixDQUFDO0lBRXZFLE1BQU1vQixVQUFVVCxjQUFjVSxHQUFHLENBQUNKLFFBQVE7UUFBRUssT0FBTztRQUFHQyxXQUFXUixNQUFPZixvQkFBb0I7SUFBTTtJQUVsRyxJQUFJZSxNQUFNSyxRQUFRRyxTQUFTLEVBQUU7UUFDM0JaLGNBQWNhLEdBQUcsQ0FBQ1AsS0FBSztZQUFFSyxPQUFPO1lBQUdDLFdBQVdSLE1BQU9mLG9CQUFvQjtRQUFNO1FBQy9FLE9BQU87SUFDVDtJQUVBLElBQUlvQixRQUFRRSxLQUFLLElBQUl4QixxQkFBcUI7UUFDeEMsT0FBTztJQUNUO0lBRUFzQixRQUFRRSxLQUFLO0lBQ2JYLGNBQWNhLEdBQUcsQ0FBQ1AsS0FBS0c7SUFDdkIsT0FBTztBQUNUO0FBRUEseUVBQXlFO0FBQ3pFLGVBQWVLLGVBQ2JYLFFBQWdCLEVBQ2hCWSxRQUFnQixFQUNoQkMsTUFBY3BDLDZDQUFTQSxDQUFDcUMsTUFBTTtJQUU5QixJQUFJQyxVQUFVO0lBRWQsTUFBT0EsVUFBVTVCLFlBQWE7UUFDOUIsSUFBSTtZQUNGLG1CQUFtQjtZQUNuQixJQUFJLENBQUNZLGVBQWVDLFdBQVc7Z0JBQzdCLE1BQU0sSUFBSVYsZUFDUix1QkFDQTtZQUVKO1lBRUEsb0JBQW9CO1lBQ3BCLE1BQU0wQixhQUFhLE1BQU16QyxxREFBYUEsQ0FBaUJxQztZQUN2RCxJQUFJSSxZQUFZO2dCQUNkLE9BQU9BO1lBQ1Q7WUFFQSx1Q0FBdUM7WUFDdkMsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLENBQUMsb0JBQW9CLEVBQUVsQixTQUFTLENBQUMsRUFBRTtnQkFDOURYLFNBQVM7b0JBQ1AsVUFBVTtvQkFDVixnQkFBZ0I7Z0JBQ2xCO2dCQUNBOEIsT0FBTztZQUNUO1lBRUUsSUFBSUYsU0FBU0csTUFBTSxLQUFLLEtBQUs7Z0JBQzNCLGlDQUFpQztnQkFDakMsTUFBTSxJQUFJQyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTbEMsY0FBY2dCLEtBQUtvQixHQUFHLENBQUMsR0FBR1Q7Z0JBQzNFQTtnQkFDQTtZQUNGO1lBRUYsSUFBSSxDQUFDRSxTQUFTUSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVQsU0FBU1UsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUl0QyxlQUNSLGFBQ0EsQ0FBQyxXQUFXLEVBQUUyQixTQUFTRyxNQUFNLENBQUMsQ0FBQyxFQUFFSCxTQUFTWSxVQUFVLENBQUMsQ0FBQyxFQUN0REg7WUFFSjtZQUVBLE1BQU1JLE9BQU8sTUFBTWIsU0FBU1UsSUFBSTtZQUNoQyxNQUFNSSxjQUE4QjtnQkFDbENEO2dCQUNBRSxXQUFXOUIsS0FBS0QsR0FBRztnQkFDbkJnQyxTQUFTO1lBQ1g7WUFFQSxxQkFBcUI7WUFDckIsTUFBTXpELHFEQUFhQSxDQUFDb0MsVUFBVW1CLGFBQWFsQjtZQUMzQyxPQUFPa0I7UUFDVCxFQUFFLE9BQU9HLE9BQU87WUFDWixJQUFJbkIsVUFBVTVCLGNBQWMsR0FBRztnQkFDN0IsTUFBTSxJQUFJa0MsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU2xDLGNBQWNnQixLQUFLb0IsR0FBRyxDQUFDLEdBQUdUO2dCQUMzRUE7Z0JBQ0E7WUFDRjtZQUNBLE1BQU1tQjtRQUNSO0lBQ0Y7SUFFQSxNQUFNLElBQUk1QyxlQUNSLHdCQUNBO0FBRUo7QUFFQSxpQkFBaUI7QUFDVixlQUFlNkM7SUFDcEIsSUFBSTtRQUNGLHVFQUF1RTtRQUN2RSxNQUFNbEIsV0FBVyxNQUFNQyxNQUFNLENBQUMsRUFBRXhDLGlCQUFpQixrQkFBa0IsQ0FBQyxFQUFFO1lBQ3BFVztZQUNBOEIsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDRixTQUFTUSxFQUFFLEVBQUU7WUFDaEIsTUFBTUMsWUFBWSxNQUFNVCxTQUFTVSxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7WUFDdEQsTUFBTSxJQUFJdEMsZUFDUixhQUNBLENBQUMsV0FBVyxFQUFFMkIsU0FBU0csTUFBTSxDQUFDLENBQUMsRUFBRUgsU0FBU1ksVUFBVSxDQUFDLENBQUMsRUFDdERIO1FBRUo7UUFFQSxNQUFNSSxPQUFPLE1BQU1iLFNBQVNVLElBQUk7UUFFaEMsTUFBTUksY0FBMEM7WUFDOUNEO1lBQ0FFLFdBQVc5QixLQUFLRCxHQUFHO1lBQ25CZ0MsU0FBUztRQUNYO1FBRUEsT0FBT0Y7SUFDVCxFQUFFLE9BQU9HLE9BQU87UUFDZCxJQUFJQSxpQkFBaUI1QyxnQkFBZ0I7WUFDbkMsTUFBTTRDO1FBQ1I7UUFDQSxNQUFNLElBQUk1QyxlQUNSLGVBQ0E0QyxpQkFBaUIzQyxRQUFRMkMsTUFBTXhDLE9BQU8sR0FBRywwQkFDekN3QztJQUVKO0FBQ0Y7QUFFQSxtQkFBbUI7QUFDWixlQUFlRTtJQUNwQixJQUFJO1FBQ0YsTUFBTW5CLFdBQVcsTUFBTU4sZUFDckIsd0JBQ0EsMkJBQ0FsQyw2Q0FBU0EsQ0FBQ3FDLE1BQU07UUFHbEIscUNBQXFDO1FBQ3JDdUIsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ3JCO1FBRTlDLHFEQUFxRDtRQUNyRCxNQUFNc0Isa0JBQW1DO1lBQ3ZDQyxRQUFRO2dCQUNOQyxhQUFhQyxPQUFPekIsU0FBU2EsSUFBSSxDQUFDVSxNQUFNLENBQUNDLFdBQVcsS0FBSztnQkFDekRFLGdCQUFnQkQsT0FBT3pCLFNBQVNhLElBQUksQ0FBQ1UsTUFBTSxDQUFDRyxjQUFjLEtBQUs7Z0JBQy9EQyxPQUFPRixPQUFPekIsU0FBU2EsSUFBSSxDQUFDVSxNQUFNLENBQUNJLEtBQUssS0FBSztZQUMvQztZQUNBQyxPQUFPO2dCQUNMQyxXQUFXSixPQUFPekIsU0FBU2EsSUFBSSxDQUFDZSxLQUFLLENBQUNDLFNBQVMsS0FBSztnQkFDcERDLFlBQVlMLE9BQU96QixTQUFTYSxJQUFJLENBQUNlLEtBQUssQ0FBQ0UsVUFBVSxLQUFLO2dCQUN0REMsY0FBY04sT0FBT3pCLFNBQVNhLElBQUksQ0FBQ2UsS0FBSyxDQUFDRyxZQUFZLEtBQUs7WUFDNUQ7UUFDRjtRQUVBLGdDQUFnQztRQUNoQyxJQUFJLENBQUNDLGtCQUFrQlYsa0JBQWtCO1lBQ3ZDLE1BQU0sSUFBSWpELGVBQ1IsZ0JBQ0EsbURBQ0FpRDtRQUVKO1FBRUEsT0FBTztZQUNMVCxNQUFNUztZQUNOUCxXQUFXOUIsS0FBS0QsR0FBRztZQUNuQmdDLFNBQVM7UUFDWDtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkLElBQUlBLGlCQUFpQjVDLGdCQUFnQjtZQUNuQyxNQUFNNEM7UUFDUjtRQUNBLE1BQU0sSUFBSTVDLGVBQ1IsZUFDQTRDLGlCQUFpQjNDLFFBQVEyQyxNQUFNeEMsT0FBTyxHQUFHLDBCQUN6Q3dDO0lBRUo7QUFDRjtBQUVBLDBDQUEwQztBQUMxQyxTQUFTZSxrQkFBa0JuQixJQUFTO0lBQ2xDLE9BQ0UsT0FBT0EsU0FBUyxZQUNoQkEsU0FBUyxRQUNULE9BQU9BLEtBQUtVLE1BQU0sS0FBSyxZQUN2QixPQUFPVixLQUFLVSxNQUFNLENBQUNDLFdBQVcsS0FBSyxZQUNuQyxPQUFPWCxLQUFLVSxNQUFNLENBQUNHLGNBQWMsS0FBSyxZQUN0QyxPQUFPYixLQUFLVSxNQUFNLENBQUNJLEtBQUssS0FBSyxZQUM3QixPQUFPZCxLQUFLZSxLQUFLLEtBQUssWUFDdEIsT0FBT2YsS0FBS2UsS0FBSyxDQUFDQyxTQUFTLEtBQUssWUFDaEMsT0FBT2hCLEtBQUtlLEtBQUssQ0FBQ0UsVUFBVSxLQUFLLFlBQ2pDLE9BQU9qQixLQUFLZSxLQUFLLENBQUNHLFlBQVksS0FBSztBQUV2QztBQUVBLE1BQU07QUFDQyxlQUFlRTtJQUNwQixJQUFJO1FBQ0YsZ0VBQWdFO1FBQ2hFLE1BQU1qQyxXQUFXLE1BQU1DLE1BQU0sWUFBWTtZQUN2Q0MsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDRixTQUFTUSxFQUFFLEVBQUU7WUFDaEIsTUFBTUMsWUFBWSxNQUFNVCxTQUFTVSxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7WUFDdEQsTUFBTSxJQUFJdEMsZUFDUixhQUNBLENBQUMsV0FBVyxFQUFFMkIsU0FBU0csTUFBTSxDQUFDLENBQUMsRUFBRUgsU0FBU1ksVUFBVSxDQUFDLENBQUMsRUFDdERIO1FBRUo7UUFFQSxNQUFNSSxPQUFPLE1BQU1iLFNBQVNVLElBQUk7UUFFaEMsT0FBT0c7SUFDVCxFQUFFLE9BQU9JLE9BQU87UUFDZCxJQUFJQSxpQkFBaUI1QyxnQkFBZ0I7WUFDbkMsTUFBTTRDO1FBQ1I7UUFDQSxNQUFNLElBQUk1QyxlQUNSLGVBQ0E0QyxpQkFBaUIzQyxRQUFRMkMsTUFBTXhDLE9BQU8sR0FBRywwQkFDekN3QztJQUVKO0FBQ0Y7QUFFQSxjQUFjO0FBQ1AsZUFBZWlCO0lBQ3BCLElBQUk7UUFDRixNQUFNbEMsV0FBVyxNQUFNQyxNQUFNLG9CQUFvQjtZQUMvQ0MsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDRixTQUFTUSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJbkMsZUFDUixhQUNBLENBQUMsV0FBVyxFQUFFMkIsU0FBU0csTUFBTSxDQUFDLENBQUMsRUFBRUgsU0FBU1ksVUFBVSxDQUFDLENBQUM7UUFFMUQ7UUFFQSxNQUFNQyxPQUFPLE1BQU1iLFNBQVNVLElBQUk7UUFFaEMsSUFBSSxDQUFDRyxRQUFRLENBQUNBLEtBQUtBLElBQUksRUFBRTtZQUN2QixNQUFNLElBQUl4QyxlQUNSLGdCQUNBO1FBRUo7UUFFQSxPQUFPO1lBQ0x3QyxNQUFNQSxLQUFLQSxJQUFJO1lBQ2ZFLFdBQVdGLEtBQUtFLFNBQVMsSUFBSTlCLEtBQUtELEdBQUc7WUFDckNnQyxTQUFTO1FBQ1g7SUFDRixFQUFFLE9BQU9DLE9BQU87UUFDZCxJQUFJQSxpQkFBaUI1QyxnQkFBZ0I7WUFDbkMsTUFBTTRDO1FBQ1I7UUFDQSxNQUFNLElBQUk1QyxlQUNSLGVBQ0E0QyxpQkFBaUIzQyxRQUFRMkMsTUFBTXhDLE9BQU8sR0FBRywwQkFDekN3QztJQUVKO0FBQ0Y7QUFFQSxnQkFBZ0I7QUFDVCxlQUFla0IsZ0JBQWdCQyxRQUFnQixFQUFFLEVBQUVDLFNBQWlCLENBQUM7SUFDMUUsSUFBSTtRQUNGLElBQUksQ0FBQ3hFLFNBQVM7WUFDWixNQUFNLElBQUlRLGVBQ1IsbUJBQ0E7UUFFSjtRQUVBLE1BQU0yQixXQUFXLE1BQU1DLE1BQU0sQ0FBQyxFQUFFeEMsaUJBQWlCLHdCQUF3QixFQUFFMkUsTUFBTSxRQUFRLEVBQUVDLE9BQU8sQ0FBQyxFQUFFO1lBQ25HakUsU0FBUztnQkFDUCxVQUFVO2dCQUNWLGlCQUFpQixDQUFDLE9BQU8sRUFBRVAsUUFBUSxDQUFDO1lBQ3RDO1lBQ0FxQyxPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUNGLFNBQVNRLEVBQUUsRUFBRTtZQUNoQixNQUFNQyxZQUFZLE1BQU1ULFNBQVNVLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztZQUN0RCxNQUFNLElBQUl0QyxlQUNSLGFBQ0EsQ0FBQyxXQUFXLEVBQUUyQixTQUFTRyxNQUFNLENBQUMsQ0FBQyxFQUFFSCxTQUFTWSxVQUFVLENBQUMsQ0FBQyxFQUN0REg7UUFFSjtRQUVBLE1BQU1JLE9BQU8sTUFBTWIsU0FBU1UsSUFBSTtRQUVoQyw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDRyxRQUFRLENBQUN5QixNQUFNQyxPQUFPLENBQUMxQixLQUFLMkIsTUFBTSxHQUFHO1lBQ3hDLE1BQU0sSUFBSW5FLGVBQ1IsZ0JBQ0Esb0NBQ0F3QztRQUVKO1FBRUEsT0FBTztZQUNMQSxNQUFNO2dCQUNKMkIsUUFBUTNCLEtBQUsyQixNQUFNO2dCQUNuQkMsWUFBWTtvQkFDVmQsT0FBT2QsS0FBSzRCLFVBQVUsRUFBRWQsU0FBU2QsS0FBSzJCLE1BQU0sQ0FBQ0UsTUFBTTtvQkFDbkRMLFFBQVF4QixLQUFLNEIsVUFBVSxFQUFFSixVQUFVQTtvQkFDbkNELE9BQU92QixLQUFLNEIsVUFBVSxFQUFFTCxTQUFTQTtnQkFDbkM7WUFDRjtZQUNBckIsV0FBVzlCLEtBQUtELEdBQUc7WUFDbkJnQyxTQUFTO1FBQ1g7SUFDRixFQUFFLE9BQU9DLE9BQU87UUFDZCxJQUFJQSxpQkFBaUI1QyxnQkFBZ0I7WUFDbkMsTUFBTTRDO1FBQ1I7UUFDQSxNQUFNLElBQUk1QyxlQUNSLGVBQ0E0QyxpQkFBaUIzQyxRQUFRMkMsTUFBTXhDLE9BQU8sR0FBRywwQkFDekN3QztJQUVKO0FBQ0Y7QUFFQSxzQkFBc0I7QUFDZixlQUFlMEIsc0JBQXNCUCxRQUFnQixFQUFFLEVBQUVDLFNBQWlCLENBQUM7SUFDaEYsSUFBSTtRQUNGLE1BQU14RSxVQUFVSCxzQ0FBZ0M7UUFFaEQsSUFBSSxDQUFDRyxTQUFTO1lBQ1osTUFBTSxJQUFJUSxlQUNSLG1CQUNBO1FBRUo7UUFFQSxNQUFNMkIsV0FBVyxNQUFNQyxNQUFNLENBQUMsRUFBRXhDLGlCQUFpQiw4QkFBOEIsRUFBRTJFLE1BQU0sUUFBUSxFQUFFQyxPQUFPLENBQUMsRUFBRTtZQUN6R2pFLFNBQVM7Z0JBQ1AsVUFBVTtnQkFDVixpQkFBaUIsQ0FBQyxPQUFPLEVBQUVQLFFBQVEsQ0FBQztZQUN0QztZQUNBcUMsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDRixTQUFTUSxFQUFFLEVBQUU7WUFDaEIsTUFBTUMsWUFBWSxNQUFNVCxTQUFTVSxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7WUFDdEQsTUFBTSxJQUFJdEMsZUFDUixhQUNBLENBQUMsV0FBVyxFQUFFMkIsU0FBU0csTUFBTSxDQUFDLENBQUMsRUFBRUgsU0FBU1ksVUFBVSxDQUFDLENBQUMsRUFDdERIO1FBRUo7UUFFQSxNQUFNSSxPQUFPLE1BQU1iLFNBQVNVLElBQUk7UUFFaEMsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ0csUUFBUSxDQUFDeUIsTUFBTUMsT0FBTyxDQUFDMUIsT0FBTztZQUNqQyxNQUFNLElBQUl4QyxlQUNSLGdCQUNBLG9DQUNBd0M7UUFFSjtRQUVBLE9BQU87WUFDTEEsTUFBTTtnQkFDSitCLGNBQWMvQjtnQkFDZDRCLFlBQVk7b0JBQ1ZkLE9BQU9kLEtBQUs2QixNQUFNO29CQUNsQkwsUUFBUUE7b0JBQ1JELE9BQU9BO2dCQUNUO1lBQ0Y7WUFDQXJCLFdBQVc5QixLQUFLRCxHQUFHO1lBQ25CZ0MsU0FBUztRQUNYO0lBQ0YsRUFBRSxPQUFPQyxPQUFPO1FBQ2QsSUFBSUEsaUJBQWlCNUMsZ0JBQWdCO1lBQ25DLE1BQU00QztRQUNSO1FBQ0EsTUFBTSxJQUFJNUMsZUFDUixlQUNBNEMsaUJBQWlCM0MsUUFBUTJDLE1BQU14QyxPQUFPLEdBQUcsMEJBQ3pDd0M7SUFFSjtBQUNGO0FBRUEscUJBQXFCO0FBQ2QsZUFBZTRCLGlCQUFpQlQsUUFBZ0IsR0FBRyxFQUFFQyxTQUFpQixDQUFDO0lBQzVFLElBQUk7UUFDRixJQUFJLENBQUN4RSxTQUFTO1lBQ1osTUFBTSxJQUFJUSxlQUNSLG1CQUNBO1FBRUo7UUFFQSxNQUFNMkIsV0FBVyxNQUFNQyxNQUFNLENBQUMsNkNBQTZDLEVBQUVtQyxNQUFNLFFBQVEsRUFBRUMsT0FBTyxDQUFDLEVBQUU7WUFDckdqRSxTQUFTO2dCQUNQLFVBQVU7Z0JBQ1YsZ0JBQWdCO1lBQ2xCO1lBQ0E4QixPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUNGLFNBQVNRLEVBQUUsRUFBRTtZQUNoQixNQUFNQyxZQUFZLE1BQU1ULFNBQVNVLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztZQUN0RCxNQUFNLElBQUl0QyxlQUNSLGFBQ0EsQ0FBQyxXQUFXLEVBQUUyQixTQUFTRyxNQUFNLENBQUMsQ0FBQyxFQUFFSCxTQUFTWSxVQUFVLENBQUMsQ0FBQyxFQUN0REg7UUFFSjtRQUVBLE1BQU1JLE9BQU8sTUFBTWIsU0FBU1UsSUFBSTtRQUVoQyw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDRyxRQUFRLENBQUN5QixNQUFNQyxPQUFPLENBQUMxQixPQUFPO1lBQ2pDLE1BQU0sSUFBSXhDLGVBQ1IsZ0JBQ0Esb0NBQ0F3QztRQUVKO1FBRUEsT0FBTztZQUNMQTtZQUNBRSxXQUFXOUIsS0FBS0QsR0FBRztZQUNuQmdDLFNBQVM7UUFDWDtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkLElBQUlBLGlCQUFpQjVDLGdCQUFnQjtZQUNuQyxNQUFNNEM7UUFDUjtRQUNBLE1BQU0sSUFBSTVDLGVBQ1IsZUFDQSw4QkFDQTRDO0lBRUo7QUFDRjtBQUVBLG1CQUFtQjtBQUNaLGVBQWU2QjtJQUNwQixJQUFJO1FBQ0YsSUFBSSxDQUFDakYsU0FBUztZQUNaLE1BQU0sSUFBSVEsZUFDUixtQkFDQTtRQUVKO1FBRUEsTUFBTTJCLFdBQVcsTUFBTUMsTUFBTSx3Q0FBd0M7WUFDbkU3QixTQUFTO2dCQUNQLFVBQVU7Z0JBQ1YsZ0JBQWdCO1lBQ2xCO1lBQ0E4QixPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUNGLFNBQVNRLEVBQUUsRUFBRTtZQUNoQixNQUFNQyxZQUFZLE1BQU1ULFNBQVNVLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztZQUN0RCxNQUFNLElBQUl0QyxlQUNSLGFBQ0EsQ0FBQyxXQUFXLEVBQUUyQixTQUFTRyxNQUFNLENBQUMsQ0FBQyxFQUFFSCxTQUFTWSxVQUFVLENBQUMsQ0FBQyxFQUN0REg7UUFFSjtRQUVBLE1BQU1JLE9BQU8sTUFBTWIsU0FBU1UsSUFBSTtRQUVoQyw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDRyxNQUFNO1lBQ1QsTUFBTSxJQUFJeEMsZUFDUixnQkFDQSxvQ0FDQXdDO1FBRUo7UUFFQSxPQUFPO1lBQ0xBO1lBQ0FFLFdBQVc5QixLQUFLRCxHQUFHO1lBQ25CZ0MsU0FBUztRQUNYO0lBQ0YsRUFBRSxPQUFPQyxPQUFPO1FBQ2QsSUFBSUEsaUJBQWlCNUMsZ0JBQWdCO1lBQ25DLE1BQU00QztRQUNSO1FBQ0EsTUFBTSxJQUFJNUMsZUFDUixlQUNBNEMsaUJBQWlCM0MsUUFBUTJDLE1BQU14QyxPQUFPLEdBQUcsMEJBQ3pDd0M7SUFFSjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sYW5hLXN0YWtpbmctZGFzaGJvYXJkLy4vc3JjL2xpYi9hcGkvc29sYW5hLnRzPzIxYWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV0d29ya1N0YXR1cywgU3VwcGx5QnJlYWtkb3duLCBBcGlSZXNwb25zZSwgVFBTRGF0YSwgTWFya2V0RGF0YSwgUmVjZW50QmxvY2tzUmVzcG9uc2UsIFJlY2VudFRyYW5zYWN0aW9uc1Jlc3BvbnNlLCBWYWxpZGF0b3IsIEdlbmVyYWxJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRDYWNoZWREYXRhLCBzZXRDYWNoZWREYXRhLCBDQUNIRV9UVEwgfSBmcm9tICcuLi9yZWRpcyc7XG5cbi8vIEJhc2UgVVJMIGZvciBTb2xhbmEgQmVhY2ggQVBJXG5leHBvcnQgY29uc3QgU09MQU5BX0JFQUNIX0FQSSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NPTEFOQV9CRUFDSF9BUElfVVJMIHx8ICdodHRwczovL3B1YmxpYy1hcGkuc29sYW5hYmVhY2guaW8nO1xuY29uc3QgQVBJX0tFWSA9IHByb2Nlc3MuZW52LlNPTEFOQV9CRUFDSF9BUElfS0VZO1xuXG4vLyBSYXRlIGxpbWl0aW5nIGNvbmZpZ3VyYXRpb25cbmNvbnN0IFJBVEVfTElNSVRfUkVRVUVTVFMgPSBwYXJzZUludChwcm9jZXNzLmVudi5SQVRFX0xJTUlUX1JFUVVFU1RTIHx8ICc1MCcsIDEwKTtcbmNvbnN0IFJBVEVfTElNSVRfV0lORE9XID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkFURV9MSU1JVF9XSU5ET1cgfHwgJzYwJywgMTApOyAvLyA2MCBzZWNvbmRzXG5jb25zdCBNQVhfUkVUUklFUyA9IDM7XG5jb25zdCBSRVRSWV9ERUxBWSA9IDEwMDA7IC8vIDEgc2Vjb25kXG5cbi8vIENvbW1vbiBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHNcbmNvbnN0IGhlYWRlcnMgPSB7XG4gICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gIC4uLihBUElfS0VZID8geyAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtBUElfS0VZfWAgfSA6IHt9KSxcbn07XG5cbi8vIEVycm9yIGhhbmRsaW5nXG5jbGFzcyBTb2xhbmFBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNvZGU6IHN0cmluZyxcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgcHVibGljIGRldGFpbHM/OiB1bmtub3duXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTb2xhbmFBcGlFcnJvcic7XG4gIH1cbn1cblxuLy8gUmF0ZSBsaW1pdGluZyBpbXBsZW1lbnRhdGlvblxuY29uc3QgcmVxdWVzdENvdW50cyA9IG5ldyBNYXA8c3RyaW5nLCB7IGNvdW50OiBudW1iZXI7IHJlc2V0VGltZTogbnVtYmVyIH0+KCk7XG5cbmZ1bmN0aW9uIGNoZWNrUmF0ZUxpbWl0KGVuZHBvaW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9OiR7TWF0aC5mbG9vcihub3cgLyAxMDAwIC8gUkFURV9MSU1JVF9XSU5ET1cpfWA7XG4gIFxuICBjb25zdCBjdXJyZW50ID0gcmVxdWVzdENvdW50cy5nZXQoa2V5KSB8fCB7IGNvdW50OiAwLCByZXNldFRpbWU6IG5vdyArIChSQVRFX0xJTUlUX1dJTkRPVyAqIDEwMDApIH07XG4gIFxuICBpZiAobm93ID4gY3VycmVudC5yZXNldFRpbWUpIHtcbiAgICByZXF1ZXN0Q291bnRzLnNldChrZXksIHsgY291bnQ6IDEsIHJlc2V0VGltZTogbm93ICsgKFJBVEVfTElNSVRfV0lORE9XICogMTAwMCkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIGlmIChjdXJyZW50LmNvdW50ID49IFJBVEVfTElNSVRfUkVRVUVTVFMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIGN1cnJlbnQuY291bnQrKztcbiAgcmVxdWVzdENvdW50cy5zZXQoa2V5LCBjdXJyZW50KTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEdlbmVyaWMgZmV0Y2ggZnVuY3Rpb24gd2l0aCBjYWNoaW5nLCByYXRlIGxpbWl0aW5nLCBhbmQgZXJyb3IgaGFuZGxpbmdcbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aENhY2hlPFQ+KFxuICBlbmRwb2ludDogc3RyaW5nLCBcbiAgY2FjaGVLZXk6IHN0cmluZywgXG4gIHR0bDogbnVtYmVyID0gQ0FDSEVfVFRMLk1FRElVTVxuKTogUHJvbWlzZTxBcGlSZXNwb25zZTxUPj4ge1xuICBsZXQgcmV0cmllcyA9IDA7XG4gIFxuICB3aGlsZSAocmV0cmllcyA8IE1BWF9SRVRSSUVTKSB7XG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgcmF0ZSBsaW1pdFxuICAgIGlmICghY2hlY2tSYXRlTGltaXQoZW5kcG9pbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hQXBpRXJyb3IoXG4gICAgICAgICdSQVRFX0xJTUlUX0VYQ0VFREVEJyxcbiAgICAgICAgJ1JhdGUgbGltaXQgZXhjZWVkZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgIGNvbnN0IGNhY2hlZERhdGEgPSBhd2FpdCBnZXRDYWNoZWREYXRhPEFwaVJlc3BvbnNlPFQ+PihjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgIHJldHVybiBjYWNoZWREYXRhO1xuICAgIH1cblxuICAgIC8vIFVzZSBwcm94eSBmb3IgYWxsIGV4dGVybmFsIEFQSSBjYWxsc1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcHJveHk/ZW5kcG9pbnQ9JHtlbmRwb2ludH1gLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBjYWNoZTogJ25vLXN0b3JlJ1xuICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgLy8gUmF0ZSBsaW1pdCBoaXQsIHdhaXQgYW5kIHJldHJ5XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBSRVRSWV9ERUxBWSAqIE1hdGgucG93KDIsIHJldHJpZXMpKSk7XG4gICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgICAnQVBJX0VSUk9SJyxcbiAgICAgICAgYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgYXBpUmVzcG9uc2U6IEFwaVJlc3BvbnNlPFQ+ID0ge1xuICAgICAgZGF0YSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICB9O1xuICAgIFxuICAgIC8vIENhY2hlIHRoZSByZXNwb25zZVxuICAgIGF3YWl0IHNldENhY2hlZERhdGEoY2FjaGVLZXksIGFwaVJlc3BvbnNlLCB0dGwpO1xuICAgIHJldHVybiBhcGlSZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChyZXRyaWVzIDwgTUFYX1JFVFJJRVMgLSAxKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBSRVRSWV9ERUxBWSAqIE1hdGgucG93KDIsIHJldHJpZXMpKSk7XG4gICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIHRocm93IG5ldyBTb2xhbmFBcGlFcnJvcihcbiAgICAnTUFYX1JFVFJJRVNfRVhDRUVERUQnLFxuICAgICdNYXhpbXVtIG51bWJlciBvZiByZXRyaWVzIGV4Y2VlZGVkJ1xuICApO1xufVxuXG4vLyBOZXR3b3JrIFN0YXR1c1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5ldHdvcmtTdGF0dXMoKTogUHJvbWlzZTxBcGlSZXNwb25zZTxOZXR3b3JrU3RhdHVzPj4ge1xuICB0cnkge1xuICAgIC8vIERpcmVjdCBmZXRjaCB3aXRob3V0IGNhY2hpbmcgZm9yIG5ldHdvcmsgc3RhdHVzIHRvIGVuc3VyZSBmcmVzaCBkYXRhXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtTT0xBTkFfQkVBQ0hfQVBJfS92MS9uZXR3b3JrLXN0YXR1c2AsIHsgXG4gICAgICBoZWFkZXJzLFxuICAgICAgY2FjaGU6ICduby1zdG9yZSdcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hQXBpRXJyb3IoXG4gICAgICAgICdBUElfRVJST1InLFxuICAgICAgICBgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBjb25zdCBhcGlSZXNwb25zZTogQXBpUmVzcG9uc2U8TmV0d29ya1N0YXR1cz4gPSB7XG4gICAgICBkYXRhLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgc3VjY2VzczogdHJ1ZVxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGFwaVJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFNvbGFuYUFwaUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgZXJyb3JcbiAgICApO1xuICB9XG59XG5cbi8vIFN1cHBseSBCcmVha2Rvd25cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdXBwbHlCcmVha2Rvd24oKTogUHJvbWlzZTxBcGlSZXNwb25zZTxTdXBwbHlCcmVha2Rvd24+PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhDYWNoZTxhbnk+KFxuICAgICAgJy92Mi9zdXBwbHktYnJlYWtkb3duJyxcbiAgICAgICdzb2xhbmE6c3VwcGx5LWJyZWFrZG93bicsXG4gICAgICBDQUNIRV9UVEwuTUVESVVNXG4gICAgKTtcblxuICAgIC8vIExvZyB0aGUgcmF3IHJlc3BvbnNlIGZvciBkZWJ1Z2dpbmdcbiAgICBjb25zb2xlLmxvZygnUmF3IHN1cHBseSBicmVha2Rvd24gcmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBkYXRhIHRvIG1hdGNoIHRoZSBleHBlY3RlZCBzdHJ1Y3R1cmVcbiAgICBjb25zdCB0cmFuc2Zvcm1lZERhdGE6IFN1cHBseUJyZWFrZG93biA9IHtcbiAgICAgIHN1cHBseToge1xuICAgICAgICBjaXJjdWxhdGluZzogTnVtYmVyKHJlc3BvbnNlLmRhdGEuc3VwcGx5LmNpcmN1bGF0aW5nKSB8fCAwLFxuICAgICAgICBub25DaXJjdWxhdGluZzogTnVtYmVyKHJlc3BvbnNlLmRhdGEuc3VwcGx5Lm5vbkNpcmN1bGF0aW5nKSB8fCAwLFxuICAgICAgICB0b3RhbDogTnVtYmVyKHJlc3BvbnNlLmRhdGEuc3VwcGx5LnRvdGFsKSB8fCAwXG4gICAgICB9LFxuICAgICAgc3Rha2U6IHtcbiAgICAgICAgZWZmZWN0aXZlOiBOdW1iZXIocmVzcG9uc2UuZGF0YS5zdGFrZS5lZmZlY3RpdmUpIHx8IDAsXG4gICAgICAgIGFjdGl2YXRpbmc6IE51bWJlcihyZXNwb25zZS5kYXRhLnN0YWtlLmFjdGl2YXRpbmcpIHx8IDAsXG4gICAgICAgIGRlYWN0aXZhdGluZzogTnVtYmVyKHJlc3BvbnNlLmRhdGEuc3Rha2UuZGVhY3RpdmF0aW5nKSB8fCAwXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFZhbGlkYXRlIHRoZSB0cmFuc2Zvcm1lZCBkYXRhXG4gICAgaWYgKCFpc1ZhbGlkU3VwcGx5RGF0YSh0cmFuc2Zvcm1lZERhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hQXBpRXJyb3IoXG4gICAgICAgICdJTlZBTElEX0RBVEEnLFxuICAgICAgICAnSW52YWxpZCBzdXBwbHkgZGF0YSBzdHJ1Y3R1cmUgcmVjZWl2ZWQgZnJvbSBBUEknLFxuICAgICAgICB0cmFuc2Zvcm1lZERhdGFcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHRyYW5zZm9ybWVkRGF0YSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFNvbGFuYUFwaUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgZXJyb3JcbiAgICApO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byB2YWxpZGF0ZSBzdXBwbHkgZGF0YVxuZnVuY3Rpb24gaXNWYWxpZFN1cHBseURhdGEoZGF0YTogYW55KTogZGF0YSBpcyBTdXBwbHlCcmVha2Rvd24ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgIGRhdGEgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgZGF0YS5zdXBwbHkgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGRhdGEuc3VwcGx5LmNpcmN1bGF0aW5nID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBkYXRhLnN1cHBseS5ub25DaXJjdWxhdGluZyA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgZGF0YS5zdXBwbHkudG90YWwgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIGRhdGEuc3Rha2UgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGRhdGEuc3Rha2UuZWZmZWN0aXZlID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBkYXRhLnN0YWtlLmFjdGl2YXRpbmcgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIGRhdGEuc3Rha2UuZGVhY3RpdmF0aW5nID09PSAnbnVtYmVyJ1xuICApO1xufVxuXG4vLyBUUFNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUUFMoKTogUHJvbWlzZTxBcGlSZXNwb25zZTxUUFNEYXRhPj4ge1xuICB0cnkge1xuICAgIC8vIERpcmVjdCBmZXRjaCB3aXRob3V0IGNhY2hpbmcgZm9yIFRQUyB0byBlbnN1cmUgcmVhbC10aW1lIGRhdGFcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3RwcycsIHtcbiAgICAgIGNhY2hlOiAnbm8tc3RvcmUnXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgICAnQVBJX0VSUk9SJyxcbiAgICAgICAgYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU29sYW5hQXBpRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgU29sYW5hQXBpRXJyb3IoXG4gICAgICAnRkVUQ0hfRVJST1InLFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCcsXG4gICAgICBlcnJvclxuICAgICk7XG4gIH1cbn1cblxuLy8gTWFya2V0IERhdGFcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNYXJrZXREYXRhKCk6IFByb21pc2U8QXBpUmVzcG9uc2U8TWFya2V0RGF0YT4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL21hcmtldC1kYXRhJywge1xuICAgICAgY2FjaGU6ICduby1zdG9yZSdcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFBcGlFcnJvcihcbiAgICAgICAgJ0FQSV9FUlJPUicsXG4gICAgICAgIGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5kYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hQXBpRXJyb3IoXG4gICAgICAgICdJTlZBTElEX0RBVEEnLFxuICAgICAgICAnSW52YWxpZCBtYXJrZXQgZGF0YSByZXNwb25zZSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgIHRpbWVzdGFtcDogZGF0YS50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFNvbGFuYUFwaUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgZXJyb3JcbiAgICApO1xuICB9XG59XG5cbi8vIFJlY2VudCBCbG9ja3NcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNlbnRCbG9ja3MobGltaXQ6IG51bWJlciA9IDUwLCBvZmZzZXQ6IG51bWJlciA9IDApOiBQcm9taXNlPEFwaVJlc3BvbnNlPFJlY2VudEJsb2Nrc1Jlc3BvbnNlPj4ge1xuICB0cnkge1xuICAgIGlmICghQVBJX0tFWSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgICAnQVBJX0tFWV9NSVNTSU5HJyxcbiAgICAgICAgJ1NvbGFuYSBCZWFjaCBBUEkga2V5IGlzIHJlcXVpcmVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke1NPTEFOQV9CRUFDSF9BUEl9L3YyL3JlY2VudC1ibG9ja3M/bGltaXQ9JHtsaW1pdH0mb2Zmc2V0PSR7b2Zmc2V0fWAsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7QVBJX0tFWX1gLFxuICAgICAgfSxcbiAgICAgIGNhY2hlOiAnbm8tc3RvcmUnXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hQXBpRXJyb3IoXG4gICAgICAgICdBUElfRVJST1InLFxuICAgICAgICBgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsXG4gICAgICAgIGVycm9yRGF0YVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoZSByZXNwb25zZSBkYXRhXG4gICAgaWYgKCFkYXRhIHx8ICFBcnJheS5pc0FycmF5KGRhdGEuYmxvY2tzKSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgICAnSU5WQUxJRF9EQVRBJyxcbiAgICAgICAgJ0ludmFsaWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gQVBJJyxcbiAgICAgICAgZGF0YVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBibG9ja3M6IGRhdGEuYmxvY2tzLFxuICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgdG90YWw6IGRhdGEucGFnaW5hdGlvbj8udG90YWwgfHwgZGF0YS5ibG9ja3MubGVuZ3RoLFxuICAgICAgICAgIG9mZnNldDogZGF0YS5wYWdpbmF0aW9uPy5vZmZzZXQgfHwgb2Zmc2V0LFxuICAgICAgICAgIGxpbWl0OiBkYXRhLnBhZ2luYXRpb24/LmxpbWl0IHx8IGxpbWl0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBzdWNjZXNzOiB0cnVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTb2xhbmFBcGlFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBTb2xhbmFBcGlFcnJvcihcbiAgICAgICdGRVRDSF9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgIGVycm9yXG4gICAgKTtcbiAgfVxufVxuXG4vLyBSZWNlbnQgVHJhbnNhY3Rpb25zXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVjZW50VHJhbnNhY3Rpb25zKGxpbWl0OiBudW1iZXIgPSA1MCwgb2Zmc2V0OiBudW1iZXIgPSAwKTogUHJvbWlzZTxBcGlSZXNwb25zZTxSZWNlbnRUcmFuc2FjdGlvbnNSZXNwb25zZT4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBBUElfS0VZID0gcHJvY2Vzcy5lbnYuU09MQU5BX0JFQUNIX0FQSV9LRVk7XG4gICAgXG4gICAgaWYgKCFBUElfS0VZKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hQXBpRXJyb3IoXG4gICAgICAgICdBUElfS0VZX01JU1NJTkcnLFxuICAgICAgICAnU29sYW5hIEJlYWNoIEFQSSBrZXkgaXMgcmVxdWlyZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7U09MQU5BX0JFQUNIX0FQSX0vdjEvbGF0ZXN0LXRyYW5zYWN0aW9ucz9saW1pdD0ke2xpbWl0fSZvZmZzZXQ9JHtvZmZzZXR9YCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtBUElfS0VZfWAsXG4gICAgICB9LFxuICAgICAgY2FjaGU6ICduby1zdG9yZSdcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFBcGlFcnJvcihcbiAgICAgICAgJ0FQSV9FUlJPUicsXG4gICAgICAgIGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhlIHJlc3BvbnNlIGRhdGFcbiAgICBpZiAoIWRhdGEgfHwgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFBcGlFcnJvcihcbiAgICAgICAgJ0lOVkFMSURfREFUQScsXG4gICAgICAgICdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIEFQSScsXG4gICAgICAgIGRhdGFcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBkYXRhLFxuICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgdG90YWw6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgc3VjY2VzczogdHJ1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU29sYW5hQXBpRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgU29sYW5hQXBpRXJyb3IoXG4gICAgICAnRkVUQ0hfRVJST1InLFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCcsXG4gICAgICBlcnJvclxuICAgICk7XG4gIH1cbn1cblxuLy8gR2V0IFRvcCBWYWxpZGF0b3JzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VG9wVmFsaWRhdG9ycyhsaW1pdDogbnVtYmVyID0gMTAwLCBvZmZzZXQ6IG51bWJlciA9IDApOiBQcm9taXNlPEFwaVJlc3BvbnNlPFZhbGlkYXRvcltdPj4ge1xuICB0cnkge1xuICAgIGlmICghQVBJX0tFWSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgICAnQVBJX0tFWV9NSVNTSU5HJyxcbiAgICAgICAgJ1NvbGFuYSBCZWFjaCBBUEkga2V5IGlzIHJlcXVpcmVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Byb3h5P2VuZHBvaW50PS92MS92YWxpZGF0b3JzL3RvcCZsaW1pdD0ke2xpbWl0fSZvZmZzZXQ9JHtvZmZzZXR9YCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgY2FjaGU6ICduby1zdG9yZSdcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFBcGlFcnJvcihcbiAgICAgICAgJ0FQSV9FUlJPUicsXG4gICAgICAgIGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgZXJyb3JEYXRhXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhlIHJlc3BvbnNlIGRhdGFcbiAgICBpZiAoIWRhdGEgfHwgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFBcGlFcnJvcihcbiAgICAgICAgJ0lOVkFMSURfREFUQScsXG4gICAgICAgICdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIEFQSScsXG4gICAgICAgIGRhdGFcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBzdWNjZXNzOiB0cnVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTb2xhbmFBcGlFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBTb2xhbmFBcGlFcnJvcihcbiAgICAgICdGRVRDSF9FUlJPUicsXG4gICAgICAnRmFpbGVkIHRvIGZldGNoIHZhbGlkYXRvcnMnLFxuICAgICAgZXJyb3JcbiAgICApO1xuICB9XG59XG5cbi8vIEdldCBHZW5lcmFsIEluZm9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRHZW5lcmFsSW5mbygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPEdlbmVyYWxJbmZvPj4ge1xuICB0cnkge1xuICAgIGlmICghQVBJX0tFWSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgICAnQVBJX0tFWV9NSVNTSU5HJyxcbiAgICAgICAgJ1NvbGFuYSBCZWFjaCBBUEkga2V5IGlzIHJlcXVpcmVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Byb3h5P2VuZHBvaW50PS92MS9nZW5lcmFsLWluZm8nLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBjYWNoZTogJ25vLXN0b3JlJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgICAnQVBJX0VSUk9SJyxcbiAgICAgICAgYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICBlcnJvckRhdGFcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGUgcmVzcG9uc2UgZGF0YVxuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgICAnSU5WQUxJRF9EQVRBJyxcbiAgICAgICAgJ0ludmFsaWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gQVBJJyxcbiAgICAgICAgZGF0YVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFNvbGFuYUFwaUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFNvbGFuYUFwaUVycm9yKFxuICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgZXJyb3JcbiAgICApO1xuICB9XG59XG4iXSwibmFtZXMiOlsiZ2V0Q2FjaGVkRGF0YSIsInNldENhY2hlZERhdGEiLCJDQUNIRV9UVEwiLCJTT0xBTkFfQkVBQ0hfQVBJIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NPTEFOQV9CRUFDSF9BUElfVVJMIiwiQVBJX0tFWSIsIlNPTEFOQV9CRUFDSF9BUElfS0VZIiwiUkFURV9MSU1JVF9SRVFVRVNUUyIsInBhcnNlSW50IiwiUkFURV9MSU1JVF9XSU5ET1ciLCJNQVhfUkVUUklFUyIsIlJFVFJZX0RFTEFZIiwiaGVhZGVycyIsIlNvbGFuYUFwaUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJtZXNzYWdlIiwiZGV0YWlscyIsIm5hbWUiLCJyZXF1ZXN0Q291bnRzIiwiTWFwIiwiY2hlY2tSYXRlTGltaXQiLCJlbmRwb2ludCIsIm5vdyIsIkRhdGUiLCJrZXkiLCJNYXRoIiwiZmxvb3IiLCJjdXJyZW50IiwiZ2V0IiwiY291bnQiLCJyZXNldFRpbWUiLCJzZXQiLCJmZXRjaFdpdGhDYWNoZSIsImNhY2hlS2V5IiwidHRsIiwiTUVESVVNIiwicmV0cmllcyIsImNhY2hlZERhdGEiLCJyZXNwb25zZSIsImZldGNoIiwiY2FjaGUiLCJzdGF0dXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJwb3ciLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsInN0YXR1c1RleHQiLCJkYXRhIiwiYXBpUmVzcG9uc2UiLCJ0aW1lc3RhbXAiLCJzdWNjZXNzIiwiZXJyb3IiLCJnZXROZXR3b3JrU3RhdHVzIiwiZ2V0U3VwcGx5QnJlYWtkb3duIiwiY29uc29sZSIsImxvZyIsInRyYW5zZm9ybWVkRGF0YSIsInN1cHBseSIsImNpcmN1bGF0aW5nIiwiTnVtYmVyIiwibm9uQ2lyY3VsYXRpbmciLCJ0b3RhbCIsInN0YWtlIiwiZWZmZWN0aXZlIiwiYWN0aXZhdGluZyIsImRlYWN0aXZhdGluZyIsImlzVmFsaWRTdXBwbHlEYXRhIiwiZ2V0VFBTIiwiZ2V0TWFya2V0RGF0YSIsImdldFJlY2VudEJsb2NrcyIsImxpbWl0Iiwib2Zmc2V0IiwiQXJyYXkiLCJpc0FycmF5IiwiYmxvY2tzIiwicGFnaW5hdGlvbiIsImxlbmd0aCIsImdldFJlY2VudFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsImdldFRvcFZhbGlkYXRvcnMiLCJnZXRHZW5lcmFsSW5mbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/api/solana.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/redis.ts":
/*!**************************!*\
  !*** ./src/lib/redis.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CACHE_TTL: () => (/* binding */ CACHE_TTL),\n/* harmony export */   clearCache: () => (/* binding */ clearCache),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   deleteCachedData: () => (/* binding */ deleteCachedData),\n/* harmony export */   getCachedData: () => (/* binding */ getCachedData),\n/* harmony export */   setCachedData: () => (/* binding */ setCachedData)\n/* harmony export */ });\n/* harmony import */ var _upstash_redis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @upstash/redis */ \"(rsc)/./node_modules/@upstash/redis/nodejs.mjs\");\n\n// In-memory cache fallback\nconst memoryCache = new Map();\n// Redis connection\nlet redis = null;\n// Initialize Redis connection\nconst initializeRedis = async ()=>{\n    if (!redis) {\n        try {\n            const redisUrl = process.env.REDIS_URL;\n            const redisToken = process.env.REDIS_PASSWORD;\n            if (!redisUrl || !redisToken) {\n                console.info(\"Redis credentials not found, using in-memory cache\");\n                return null;\n            }\n            console.info(\"Connecting to Redis\");\n            redis = new _upstash_redis__WEBPACK_IMPORTED_MODULE_0__.Redis({\n                url: redisUrl,\n                token: redisToken\n            });\n            // Test the connection\n            await redis.ping();\n            console.info(\"Successfully connected to Redis\");\n            return redis;\n        } catch (error) {\n            console.warn(\"Redis connection failed, falling back to in-memory cache:\", error);\n            return null;\n        }\n    }\n    return redis;\n};\n// Cache TTL constants (in seconds)\nconst CACHE_TTL = {\n    SHORT: parseInt(process.env.CACHE_TTL_SHORT || \"60\", 10),\n    MEDIUM: parseInt(process.env.CACHE_TTL_MEDIUM || \"300\", 10),\n    LONG: parseInt(process.env.CACHE_TTL_LONG || \"3600\", 10)\n};\n// Get data from cache\nasync function getCachedData(key) {\n    try {\n        const redisInstance = await initializeRedis();\n        if (redisInstance) {\n            const data = await redisInstance.get(key);\n            return data;\n        }\n        // Fallback to in-memory cache\n        const cached = memoryCache.get(key);\n        if (cached && cached.expiry > Date.now()) {\n            return cached.data;\n        }\n        memoryCache.delete(key);\n        return null;\n    } catch (error) {\n        console.error(\"Cache get error:\", error);\n        return null;\n    }\n}\n// Set data in cache\nasync function setCachedData(key, data, ttl) {\n    try {\n        const redisInstance = await initializeRedis();\n        if (redisInstance) {\n            await redisInstance.set(key, data, {\n                ex: ttl\n            });\n            return;\n        }\n        // Fallback to in-memory cache\n        const expiry = Date.now() + ttl * 1000;\n        memoryCache.set(key, {\n            data,\n            expiry\n        });\n    } catch (error) {\n        console.error(\"Cache set error:\", error);\n    }\n}\n// Delete data from cache\nasync function deleteCachedData(key) {\n    try {\n        const redisInstance = await initializeRedis();\n        if (redisInstance) {\n            await redisInstance.del(key);\n            return;\n        }\n        memoryCache.delete(key);\n    } catch (error) {\n        console.error(\"Cache delete error:\", error);\n    }\n}\n// Clear all cache\nasync function clearCache() {\n    try {\n        const redisInstance = await initializeRedis();\n        if (redisInstance) {\n            await redisInstance.flushall();\n            return;\n        }\n        memoryCache.clear();\n    } catch (error) {\n        console.error(\"Cache clear error:\", error);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (redis);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eEI7UUFDNUIsSUFBSXdCLGVBQWU7WUFDakIsTUFBTUEsY0FBY2UsUUFBUTtZQUM1QjtRQUNGO1FBQ0ExQyxZQUFZMkMsS0FBSztJQUNuQixFQUFFLE9BQU81QixPQUFPO1FBQ2RMLFFBQVFLLEtBQUssQ0FBQyxzQkFBc0JBO0lBQ3RDO0FBQ0Y7QUFFQSxpRUFBZWIsS0FBS0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NvbGFuYS1zdGFraW5nLWRhc2hib2FyZC8uL3NyYy9saWIvcmVkaXMudHM/OTI1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWRpcyB9IGZyb20gJ0B1cHN0YXNoL3JlZGlzJztcclxuXHJcbi8vIEluLW1lbW9yeSBjYWNoZSBmYWxsYmFja1xyXG5jb25zdCBtZW1vcnlDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCB7IGRhdGE6IGFueTsgZXhwaXJ5OiBudW1iZXIgfT4oKTtcclxuXHJcbi8vIFJlZGlzIGNvbm5lY3Rpb25cclxubGV0IHJlZGlzOiBSZWRpcyB8IG51bGwgPSBudWxsO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBSZWRpcyBjb25uZWN0aW9uXHJcbmNvbnN0IGluaXRpYWxpemVSZWRpcyA9IGFzeW5jICgpID0+IHtcclxuICBpZiAoIXJlZGlzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZWRpc1VybCA9IHByb2Nlc3MuZW52LlJFRElTX1VSTDtcclxuICAgICAgY29uc3QgcmVkaXNUb2tlbiA9IHByb2Nlc3MuZW52LlJFRElTX1BBU1NXT1JEO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFyZWRpc1VybCB8fCAhcmVkaXNUb2tlbikge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnUmVkaXMgY3JlZGVudGlhbHMgbm90IGZvdW5kLCB1c2luZyBpbi1tZW1vcnkgY2FjaGUnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5pbmZvKCdDb25uZWN0aW5nIHRvIFJlZGlzJyk7XHJcbiAgICAgIHJlZGlzID0gbmV3IFJlZGlzKHtcclxuICAgICAgICB1cmw6IHJlZGlzVXJsLFxyXG4gICAgICAgIHRva2VuOiByZWRpc1Rva2VuLFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIC8vIFRlc3QgdGhlIGNvbm5lY3Rpb25cclxuICAgICAgYXdhaXQgcmVkaXMucGluZygpO1xyXG4gICAgICBjb25zb2xlLmluZm8oJ1N1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgdG8gUmVkaXMnKTtcclxuICAgICAgcmV0dXJuIHJlZGlzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdSZWRpcyBjb25uZWN0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBjYWNoZTonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVkaXM7XHJcbn07XHJcblxyXG4vLyBDYWNoZSBUVEwgY29uc3RhbnRzIChpbiBzZWNvbmRzKVxyXG5leHBvcnQgY29uc3QgQ0FDSEVfVFRMID0ge1xyXG4gIFNIT1JUOiBwYXJzZUludChwcm9jZXNzLmVudi5DQUNIRV9UVExfU0hPUlQgfHwgJzYwJywgMTApLCAgICAvLyAxIG1pbnV0ZVxyXG4gIE1FRElVTTogcGFyc2VJbnQocHJvY2Vzcy5lbnYuQ0FDSEVfVFRMX01FRElVTSB8fCAnMzAwJywgMTApLCAgIC8vIDUgbWludXRlc1xyXG4gIExPTkc6IHBhcnNlSW50KHByb2Nlc3MuZW52LkNBQ0hFX1RUTF9MT05HIHx8ICczNjAwJywgMTApLCAgICAvLyAxIGhvdXJcclxufTtcclxuXHJcbi8vIEdldCBkYXRhIGZyb20gY2FjaGVcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlZERhdGE8VD4oa2V5OiBzdHJpbmcpOiBQcm9taXNlPFQgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlZGlzSW5zdGFuY2UgPSBhd2FpdCBpbml0aWFsaXplUmVkaXMoKTtcclxuICAgIGlmIChyZWRpc0luc3RhbmNlKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZWRpc0luc3RhbmNlLmdldDxUPihrZXkpO1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRmFsbGJhY2sgdG8gaW4tbWVtb3J5IGNhY2hlXHJcbiAgICBjb25zdCBjYWNoZWQgPSBtZW1vcnlDYWNoZS5nZXQoa2V5KTtcclxuICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmV4cGlyeSA+IERhdGUubm93KCkpIHtcclxuICAgICAgcmV0dXJuIGNhY2hlZC5kYXRhO1xyXG4gICAgfVxyXG4gICAgbWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQ2FjaGUgZ2V0IGVycm9yOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gU2V0IGRhdGEgaW4gY2FjaGVcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldENhY2hlZERhdGE8VD4oa2V5OiBzdHJpbmcsIGRhdGE6IFQsIHR0bDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlZGlzSW5zdGFuY2UgPSBhd2FpdCBpbml0aWFsaXplUmVkaXMoKTtcclxuICAgIGlmIChyZWRpc0luc3RhbmNlKSB7XHJcbiAgICAgIGF3YWl0IHJlZGlzSW5zdGFuY2Uuc2V0KGtleSwgZGF0YSwgeyBleDogdHRsIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBjYWNoZVxyXG4gICAgY29uc3QgZXhwaXJ5ID0gRGF0ZS5ub3coKSArICh0dGwgKiAxMDAwKTtcclxuICAgIG1lbW9yeUNhY2hlLnNldChrZXksIHsgZGF0YSwgZXhwaXJ5IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDYWNoZSBzZXQgZXJyb3I6JywgZXJyb3IpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRGVsZXRlIGRhdGEgZnJvbSBjYWNoZVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ2FjaGVkRGF0YShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZWRpc0luc3RhbmNlID0gYXdhaXQgaW5pdGlhbGl6ZVJlZGlzKCk7XHJcbiAgICBpZiAocmVkaXNJbnN0YW5jZSkge1xyXG4gICAgICBhd2FpdCByZWRpc0luc3RhbmNlLmRlbChrZXkpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBtZW1vcnlDYWNoZS5kZWxldGUoa2V5KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQ2FjaGUgZGVsZXRlIGVycm9yOicsIGVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENsZWFyIGFsbCBjYWNoZVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYXJDYWNoZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVkaXNJbnN0YW5jZSA9IGF3YWl0IGluaXRpYWxpemVSZWRpcygpO1xyXG4gICAgaWYgKHJlZGlzSW5zdGFuY2UpIHtcclxuICAgICAgYXdhaXQgcmVkaXNJbnN0YW5jZS5mbHVzaGFsbCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBtZW1vcnlDYWNoZS5jbGVhcigpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDYWNoZSBjbGVhciBlcnJvcjonLCBlcnJvcik7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCByZWRpczsgIl0sIm5hbWVzIjpbIlJlZGlzIiwibWVtb3J5Q2FjaGUiLCJNYXAiLCJyZWRpcyIsImluaXRpYWxpemVSZWRpcyIsInJlZGlzVXJsIiwicHJvY2VzcyIsImVudiIsIlJFRElTX1VSTCIsInJlZGlzVG9rZW4iLCJSRURJU19QQVNTV09SRCIsImNvbnNvbGUiLCJpbmZvIiwidXJsIiwidG9rZW4iLCJwaW5nIiwiZXJyb3IiLCJ3YXJuIiwiQ0FDSEVfVFRMIiwiU0hPUlQiLCJwYXJzZUludCIsIkNBQ0hFX1RUTF9TSE9SVCIsIk1FRElVTSIsIkNBQ0hFX1RUTF9NRURJVU0iLCJMT05HIiwiQ0FDSEVfVFRMX0xPTkciLCJnZXRDYWNoZWREYXRhIiwia2V5IiwicmVkaXNJbnN0YW5jZSIsImRhdGEiLCJnZXQiLCJjYWNoZWQiLCJleHBpcnkiLCJEYXRlIiwibm93IiwiZGVsZXRlIiwic2V0Q2FjaGVkRGF0YSIsInR0bCIsInNldCIsImV4IiwiZGVsZXRlQ2FjaGVkRGF0YSIsImRlbCIsImNsZWFyQ2FjaGUiLCJmbHVzaGFsbCIsImNsZWFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/redis.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@upstash","vendor-chunks/crypto-js"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fproxy%2Froute&page=%2Fapi%2Fproxy%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fproxy%2Froute.ts&appDir=D%3A%5Csolana-staking-dashboard%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=D%3A%5Csolana-staking-dashboard&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();